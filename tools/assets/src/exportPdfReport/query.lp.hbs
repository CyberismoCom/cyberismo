{{#if cardKey}}
result({{cardKey}}).

{{#if recursive}}
result(Card) :- parent(Card, Parent), result(Parent).
{{/if}}

{{else}}
result(Card) :- projectCard(Card), not hiddenInTreeView(Card).
{{/if}}

% Calculate depth levels
cardLevel(Card, 1) :- result(Card), not parent(Card, _).
cardLevel(Card, Level + 1) :- 
    cardLevel(Parent, Level), 
    parent(Card, Parent), 
    result(Card).

% Create a path-based ordering system using string concatenation
% For each card, create a path that represents its position in the tree
% Root cards: just their rank (already lexicographically sortable)
% Child cards: parent's path + "." + own rank

% Base case: root cards use their rank directly as the path
treePath(Card, Rank) :- 
    cardLevel(Card, 1),
    result(Card),
    field(Card, "rank", Rank).

% Recursive case: children append their rank to parent's path
treePath(Card, FullPath) :-
    cardLevel(Card, Level),
    Level > 1,
    parent(Card, Parent),
    treePath(Parent, ParentPath),
    field(Card, "rank", Rank),
    result(Card),
    FullPath = @concatenate(ParentPath, "!", Rank).

% Sort by tree path (lexicographic ordering will give us depth-first)
order(1, "results", 1, "treePath", "ASC").

% Select the fields we need
select("key";"levelOffset";"treePath").

% Map level to levelOffset and add tree path for sorting
field(Card, "levelOffset", Level) :- cardLevel(Card, Level), result(Card).
field(Card, "treePath", Path) :- treePath(Card, Path), result(Card).








